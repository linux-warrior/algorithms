# https://contest.yandex.ru/contest/25597/run-report/152659317/
#
# -- Принцип работы --
#
# Функция `can_be_partitioned_equally()` решает задачу разбиения множества чисел (partition problem).
# Нам необходимо определить, возможно ли разделить мультимножество неотрицательных целых чисел `values`
# на два подмножества с одинаковой суммой элементов. Если сумма всех элементов `values` — нечетное
# число, то задача не имеет решения. Если же сумма имеет четное значение, то исходная задача сводится
# к поиску подмножества, сумма элементов которого равна половине суммы всех элементов `values`. Далее
# мы обозначим это значение суммы как `target_sum`.
#
# Согласно условию для исходных данных, и мощность мультимножества `values`, и значения его элементов
# не превосходят 300. Поэтому в данном случае для решения задачи разбиения можно использовать метод
# динамического программирования. В отличие от классического псевдополиномиального алгоритма, в целях
# экономии памяти мы не будем сохранять целиком всю матрицу, определяющую возможность собрать значение
# суммы `0 ⩽ possible_sum ⩽ target_sum` из элементов различных подмножеств `values`. Вместо этой
# матрицы мы используем одномерный массив, содержащий значения флага существования возможной суммы
# элементов для некоторого подмножества `values`, в которое мы в цикле по очереди добавляем все
# элементы. Поэтому чтобы раньше времени не перезаписывать результаты, полученные на предыдущем шаге
# внешнего цикла по элементам `values`, внутренний цикл по возможным значениям суммы элементов
# необходимо выполнять в обратном направлении.
#
# -- Доказательство корректности --
#
# Подробный анализ псевдополиномиального алгоритма разбиения множества целых неотрицательных чисел
# можно найти в открытых источниках:
# https://en.wikipedia.org/wiki/Pseudopolynomial_time_number_partitioning
#
# -- Временная сложность --
#
# Пусть `m` — максимальный элемент мультимножества `values`, а `n` — мощность `values`. Тогда
# `target_sum ⩽ mn / 2`, а временная сложность алгоритма составляет `O(n · target_sum) = O(mn²)`.
#
# -- Пространственная сложность --
#
# Поскольку промежуточные результаты работы алгоритма сохраняются в одномерный массив длиной
# `target_sum + 1`, пространственная сложность алгоритма составляет `O(target_sum) = O(mn)`.

from __future__ import annotations

import itertools
import sys
from collections.abc import Collection


def can_be_partitioned_equally(values: Collection[int]) -> bool:
    values_sum = sum(values)

    if values_sum % 2:
        return False

    target_sum = values_sum // 2
    results = [False] * (target_sum + 1)
    results[0] = True

    for value in values:
        for possible_sum in range(target_sum, value - 1, -1):
            if results[possible_sum - value]:
                results[possible_sum] = True

    return results[target_sum]


def main() -> None:
    values_count = int(input().strip())
    values = list(itertools.islice(
        map(int, sys.stdin.readline().split()),
        values_count,
    ))
    print(can_be_partitioned_equally(values))


if __name__ == '__main__':
    main()
